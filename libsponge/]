#include "stream_reassembler.hh"

#include <cstdio>

// Dummy implementation of a stream reassembler.

// For Lab 1, please replace with a real implementation that passes the
// automated checks run by `make check_lab1`.

// You will need to add private members to the class declaration in `stream_reassembler.hh`

template <typename... Targs>
void DUMMY_CODE(Targs &&.../* unused */) {}

using namespace std;

StreamReassembler::StreamReassembler(const size_t capacity)
    : _output(capacity)
    , _capacity(capacity)
    , _first_unassembled_index(0)
    , _first_unaccepted_index(_capacity)
    , _unass_window({})
    , _eof_index(0)
    , _eof(false) {}

//! \details This function accepts a substring (aka a segment) of bytes,
//! possibly out-of-order, from the logical stream, and assembles any newly
//! contiguous substrings and writes them into the output stream in order.

void StreamReassembler::store_unass_buffer(size_t index, std::string &data) {
    // clear chars before the index of current data
    size_t first_unaccept_idx = _first_unassembled_index + _capacity - _output.buffer_size();
    auto iter = _unass_window.lower_bound(index);
    _unass_window.erase(_unass_window.begin(), iter);
    // store
    while (index < first_unaccept_idx) {
        _unass_window[index] = data.at(index);
        index++;
    }
}

void StreamReassembler::push_substring(const string &data, const size_t index, const bool eof) {}

size_t StreamReassembler::unassembled_bytes() const { return _unass_window.size(); }

bool StreamReassembler::empty() const { return _output.empty() && _unassembled_bytes.empty(); }
